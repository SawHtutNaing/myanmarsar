**Myanmar Sar Project Report**

**1. Project Overview**

The "Myanmar Sar" project is a web-based restaurant management system designed to streamline various restaurant operations. Built using the Laravel framework, it provides a comprehensive solution for managing orders, ingredients, food items, tables, and users. The system caters to different user roles within a restaurant, including administrators, waiters, kitchen staff, and suppliers, each with a specific set of permissions and functionalities. The application aims to replace manual processes with a digitized and automated system, improving efficiency, reducing errors, and providing better insights into the restaurant's performance through reporting features.

**2. Architecture**

The application follows the classic Model-View-Controller (MVC) architectural pattern, which is standard for Laravel projects.

*   **Model**: The models are located in the `app/Models/` directory. They are responsible for representing the application's data structure and interacting with the database. Key models include `User`, `Role`, `Order`, `FoodItem`, `Ingredient`, and `Table`. These models define the relationships between different data entities (e.g., a `User` has a `Role`, an `Order` has many `OrderItems`).

*   **View**: The views are located in the `resources/views/` directory and are written using Laravel's Blade templating engine. They are responsible for presenting the data to the user and capturing user input. The views are organized into folders based on their functionality (e.g., `admin`, `waiter`, `kitchen`). The project uses Tailwind CSS for styling, which is a utility-first CSS framework that allows for rapid UI development. Alpine.js is used for adding client-side interactivity to the Blade templates.

*   **Controller**: The controllers are located in the `app/Http/Controllers/` directory. They act as the intermediary between the Models and Views, handling incoming HTTP requests, processing user input, interacting with the database through the models, and loading the appropriate views with the necessary data. The controllers are organized by user roles, such as `AdminController`, `WaiterController`, and `KitchenController`, which helps in managing the business logic for each role.

**3. Core Features & User Roles**

The system has four main user roles, each with a dedicated dashboard and a set of features tailored to their responsibilities.

*   **Admin**: The administrator has the highest level of access and is responsible for managing the entire system. The admin's features include:
    *   **Dashboard**: An overview of the restaurant's activities.
    *   **User Management**: CRUD (Create, Read, Update, Delete) operations for users.
    *   **Ingredient Management**: CRUD operations for ingredients.
    *   **Food Item Management**: CRUD operations for food items.
    *   **Table Management**: CRUD operations for tables.
    *   **Order Management**: Viewing and managing all orders.
    *   **Reporting**: Access to various reports, including sales reports, profit and loss reports, and ingredient import reports.

*   **Waiter**: The waiter is responsible for taking and managing customer orders. The waiter's features include:
    *   **Dashboard**: A view of their current orders and table statuses.
    *   **Menu**: Access to the list of available food items.
    *   **Order Creation**: Creating new orders for customers.
    *   **Order Management**: Adding items to existing orders, updating order statuses, and managing tables.
    *   **Order History**: Viewing their past orders.

*   **Kitchen**: The kitchen staff is responsible for preparing the food orders. The kitchen's features include:
    *   **Dashboard**: A real-time view of incoming orders.
    *   **Order Status**: Marking orders as "in progress" or "completed".

*   **Supplier**: Although less detailed in the provided file structure, a `supplier` role is defined, suggesting a feature for managing ingredient supplies and imports. This would likely involve:
    *   **Ingredient Import Management**: Creating and managing ingredient import records.

**4. Database Schema**

The database schema is defined through a series of migration files in the `database/migrations/` directory. The key tables are:

*   `users`: Stores user information, including name, email, and password.
*   `roles`: Stores the different user roles (e.g., 'admin', 'waiter', 'kitchen').
*   `role_user`: A pivot table for the many-to-many relationship between users and roles.
*   `ingredients`: Stores information about each ingredient, such as name, unit, and quantity.
*   `food_items`: Stores information about each food item on the menu, including name, price, and description.
*   `food_item_ingredient`: A pivot table for the many-to-many relationship between food items and ingredients, specifying the quantity of each ingredient required for a food item.
*   `orders`: Stores information about each order, including the table number, status, and total amount.
*   `order_items`: Stores the items included in each order, linking to the `food_items` table and specifying the quantity.
*   `tables`: Stores information about the restaurant's tables, such as table number and capacity.
*   `ingredient_imports`: Stores records of ingredient imports.
*   `table_bill_out_records`: Stores records of billed out tables.
*   `expense_groups`: Groups expenses into categories.
*   `expense_details`: Stores details of each expense.

**5. User Roles and Permissions**

The application uses a custom role-based permission system.

*   **`RoleMiddleware`**: This middleware, located at `app/Http/Middleware/RoleMiddleware.php`, is used to restrict access to certain routes based on the user's role. It checks if the authenticated user has the required role before allowing them to proceed.

*   **`hasRole` method**: The `User` model (`app/Models/User.php`) contains a `hasRole` method that checks if a user has a specific role. This method is used by the `RoleMiddleware` to perform the authorization check. The User model also defines a `roles` relationship, which is a many-to-many relationship with the `Role` model.

*   **Role Seeder**: The `database/seeders/RoleSeeder.php` file is used to populate the `roles` table with the default roles: 'admin', 'waiter', 'kitchen', and 'supplier'.

**6. Routing**

The application's routes are defined in `routes/web.php`. The routes are grouped by middleware to apply authentication and role-based access control.

*   **Authentication Routes**: The routes for login, registration, and password reset are defined here, typically using `Auth::routes()`.
*   **Admin Routes**: Routes prefixed with `/admin` are grouped and protected by the `auth` and `role:admin` middleware. These routes map to the methods in the `AdminController`, `UserController`, `IngredientController`, `FoodItemController`, etc.
*   **Waiter Routes**: Routes prefixed with `/waiter` are protected by the `auth` and `role:waiter` middleware and are handled by the `WaiterController`.
*   **Kitchen Routes**: Routes prefixed with `/kitchen` are protected by the `auth` and `role:kitchen` middleware and are handled by the `KitchenController`.

**7. Frontend**

The frontend of the application is built with:

*   **Blade Templates**: Laravel's templating engine is used to create the views.
*   **Tailwind CSS**: A utility-first CSS framework for styling the. The configuration is in `tailwind.config.js`.
*   **Alpine.js**: A lightweight JavaScript framework for adding client-side interactivity.
*   **Vite**: A modern frontend build tool that is used for asset bundling. The configuration is in `vite.config.js`.

**8. Dependencies**

*   **Backend (from `composer.json`)**:
    *   `php`: ^8.2
    *   `laravel/framework`: ^11.0 (Inferred from file structure)
    *   `laravel/sanctum`: For API authentication.
    *   And other standard Laravel packages.

*   **Frontend (from `package.json`)**:
    *   `alpinejs`: For client-side interactivity.
    *   `autoprefixer`: For CSS vendor prefixes.
    *   `axios`: For making HTTP requests from the client-side.
    *   `laravel-vite-plugin`: To integrate Vite with Laravel.
    *   `postcss`: For CSS processing.
    *   `tailwindcss`: The CSS framework.
    *   `vite`: The build tool.
